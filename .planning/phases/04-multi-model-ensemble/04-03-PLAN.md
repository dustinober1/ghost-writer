---
phase: 04-multi-model-ensemble
plan: 03
type: execute
wave: 3
depends_on: [04-01, 04-02]
files_modified:
  - backend/app/ml/temporal/__init__.py
  - backend/app/ml/temporal/version_tracker.py
  - backend/app/ml/temporal/timeline_analyzer.py
  - backend/app/ml/temporal/injection_detector.py
  - backend/app/models/database.py
  - backend/app/models/schemas.py
  - backend/app/api/routes/temporal.py
  - frontend/src/components/TemporalAnalysis/TemporalAnalysis.tsx
autonomous: true

must_haves:
  truths:
    - "User can view writing timeline showing AI probability evolution across document versions"
    - "System detects AI injection points (high-AI sections added in later versions)"
    - "User can compare two drafts to identify AI-generated additions"
    - "Mixed authorship indicators highlight suspicious transitions"
    - "Document version history stored with timestamps and segment-level AI scores"
  artifacts:
    - path: "backend/app/ml/temporal/version_tracker.py"
      provides: "Document version history tracking"
      min_lines: 80
      exports: ["VersionTracker", "store_version", "get_version_history", "compare_versions"]
    - path: "backend/app/ml/temporal/timeline_analyzer.py"
      provides: "Writing timeline analysis with trend detection"
      min_lines: 100
      exports: ["TimelineAnalyzer", "analyze_timeline", "detect_trend"]
    - path: "backend/app/ml/temporal/injection_detector.py"
      provides: "AI injection detection across versions"
      min_lines: 80
      exports: ["InjectionDetector", "detect_injections", "find_suspicious_additions"]
    - path: "backend/app/models/database.py"
      provides: "DocumentVersion database table"
      contains: "class DocumentVersion"
    - path: "frontend/src/components/TemporalAnalysis/TemporalAnalysis.tsx"
      provides: "Temporal analysis visualization UI"
      min_lines: 150
  key_links:
    - from: "backend/app/api/routes/temporal.py"
      to: "backend/app/ml/temporal/timeline_analyzer.py"
      via: "TimelineAnalyzer for timeline analysis"
      pattern: "TimelineAnalyzer"
    - from: "backend/app/ml/temporal/injection_detector.py"
      to: "backend/app/ml/temporal/version_tracker.py"
      via: "VersionTracker for accessing document versions"
      pattern: "VersionTracker"
    - from: "frontend/src/components/TemporalAnalysis/TemporalAnalysis.tsx"
      to: "/api/temporal/timeline"
      via: "Fetch timeline data for document"
      pattern: "fetch.*api/temporal"
---

<objective>
Implement temporal analysis system for detecting AI injection and tracking document evolution, enabling users to identify when AI-generated content was inserted into documents.

Purpose: Documents evolve over time through edits and revisions. AI detection becomes more powerful when we can track AI probability changes across versions - detecting when high-AI content was inserted (AI injection) and visualizing the writing timeline to identify suspicious transitions.

Output: Temporal analysis system with document version tracking, injection detection, draft comparison, and UI visualization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-multi-model-ensemble/04-RESEARCH.md

@.planning/phases/04-multi-model-ensemble/04-01-PLAN.md
@.planning/phases/04-multi-model-ensemble/04-02-PLAN.md
@backend/app/services/analysis_service.py
@backend/app/models/database.py
@backend/app/models/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Implement document version tracking</name>
  <files>backend/app/ml/temporal/version_tracker.py, backend/app/models/database.py</files>
  <action>
    Create backend/app/ml/temporal/__init__.py with:
    from .version_tracker import VersionTracker
    from .timeline_analyzer import TimelineAnalyzer
    from .injection_detector import InjectionDetector

    Create backend/app/ml/temporal/version_tracker.py:

    1. VersionTracker class:
       - __init__(db_session): initializes with database session
       - Stores document versions with timestamps and AI scores

    2. store_version(user_id: int, document_id: str, content: str, analysis_result: dict) -> int:
       - Stores new document version in database
       - Includes: version_number, content_hash, created_at
       - Stores segment-level AI probabilities for comparison
       - Returns version_id

    3. get_version_history(document_id: str) -> list:
       - Returns all versions for a document, ordered by created_at
       - Each version includes: version_number, created_at, word_count, segment_ai_scores
       - Raises DocumentNotFound if no versions exist

    4. compare_versions(version_a_id: int, version_b_id: int) -> dict:
       - Uses difflib.SequenceMatcher to find differences
       - Returns:
         * added_sections: list of {text, position, ai_probability}
         * removed_sections: list of {text, position}
         * modified_sections: list of {old_text, new_text, position, delta_ai}
       - Position is character index in document

    5. get_latest_version(document_id: str) -> dict:
       - Returns most recent version
       - Useful for "current state" comparison

    Add to backend/app/models/database.py:
    - DocumentVersion table:
      * id: Integer, primary key
      * user_id: Integer, ForeignKey(users.id)
      * document_id: String, index (external document identifier)
      * version_number: Integer
      * content: Text
      * content_hash: String (SHA-256 for deduplication)
      * segment_ai_scores: JSON (array of per-segment scores)
      * overall_ai_probability: Float
      * word_count: Integer
      * created_at: DateTime, index=True
      * analysis_metadata: JSON (stores full analysis result)

    Relationship:
    - User.versions = relationship("DocumentVersion", cascade="all, delete-orphan")

    Use difflib.SequenceMatcher for diffing - DON'T implement custom diff algorithm.
  </action>
  <verify>
    python -c "from backend.app.ml.temporal.version_tracker import VersionTracker; print('VersionTracker imported')"
  </verify>
  <done>
    VersionTracker stores/retrieves document versions, compare_versions() finds added/removed/modified sections with AI probabilities
  </done>
</task>

<task type="auto">
  <name>Implement timeline analysis and injection detection</name>
  <files>backend/app/ml/temporal/timeline_analyzer.py, backend/app/ml/temporal/injection_detector.py</files>
  <action>
    Create backend/app/ml/temporal/timeline_analyzer.py:

    1. TimelineAnalyzer class:
       - __init__(version_tracker: VersionTracker)

    2. analyze_timeline(document_id: str) -> dict:
       - Gets all versions from version_tracker
       - For each version, calculates:
         * avg_ai_prob: mean of segment scores
         * max_ai_prob: maximum segment score
         * high_confidence_count: segments with ai_prob > 0.7
         * word_count
         * timestamp
       - Returns:
         * timeline: list of version stats
         * overall_trend: 'increasing', 'decreasing', 'stable', 'insufficient_data'
         * ai_velocity: rate of AI probability change

    3. detect_trend(timeline_data: list) -> str:
       - Compares first and last average AI probabilities
       - Threshold: 0.2 difference = trend
       * increasing: last - first > 0.2
       * decreasing: first - last > 0.2
       * stable: difference < 0.2
       * insufficient_data: < 3 versions

    Create backend/app/ml/temporal/injection_detector.py:

    1. InjectionDetector class:
       - __init__(version_tracker: VersionTracker, threshold: float = 0.7)
       - threshold: AI probability above which content is flagged

    2. detect_injections(document_id: str) -> list:
       - Gets version history
       - Compares each adjacent version pair
       - Identifies injection events:
         * Added sections with ai_prob > threshold
         * Modified sections with delta_ai > 0.3
       - Returns list of injection events:
         * version: int (version where injection occurred)
         * timestamp: datetime
         * position: int
         * text: str (truncated to 100 chars)
         * ai_probability: float
         * type: 'addition' | 'modification'

    3. find_suspicious_additions(versions: list) -> list:
       - Filters added sections by AI probability threshold
       - Ranks by ai_probability (highest first)
       - Returns top N suspicious additions

    4. calculate_injection_score(document_id: str) -> float:
       - Overall measure of AI injection severity
       * Formula: (sum of injection_ai_probs) / (total_words)
       * Returns 0-1 score

    5. detect_mixed_authorship_indicators(versions: list) -> list:
       - Detects patterns indicating mixed human-AI authorship:
         * Variance discrepancy: prob_variance changes > 0.1
         * Burstiness discrepancy: burstiness changes > 0.5
         * Sudden style shift: perplexity changes > 30
       - Returns list of indicators with descriptions

    Integration:
    - TimelineAnalyzer uses VersionTracker.get_version_history()
    - InjectionDetector uses VersionTracker.compare_versions()
    - Both call ensemble for AI probability analysis on new versions
  </action>
  <verify>
    python -c "from backend.app.ml.temporal.timeline_analyzer import TimelineAnalyzer; from backend.app.ml.temporal.injection_detector import InjectionDetector; print('Temporal modules imported')"
  </verify>
  <done>
    TimelineAnalyzer generates timeline with trend detection, InjectionDetector identifies AI injection points with scoring
  </done>
</task>

<task type="auto">
  <name>Create temporal analysis API and frontend UI</name>
  <files>backend/app/api/routes/temporal.py, backend/app/models/schemas.py, frontend/src/components/TemporalAnalysis/TemporalAnalysis.tsx</files>
  <action>
    Create backend/app/api/routes/temporal.py:

    1. POST /api/temporal/version:
       - Stores new document version
       - Body: {document_id: str, content: str}
       - Runs analysis using ensemble
       - Returns: {version_id: int, version_number: int, created_at: datetime}

    2. GET /api/temporal/timeline/{document_id}:
       - Returns timeline analysis for document
       - Response: {timeline: [...], overall_trend: str, ai_velocity: float, injection_events: [...]}

    3. GET /api/temporal/versions/{document_id}:
       - Returns all versions for document
       - Response: {versions: [...], total_versions: int}

    4. POST /api/temporal/compare:
       - Compares two document versions
       - Body: {document_id: str, version_a: int, version_b: int}
       - Response: {added: [...], removed: [...], modified: [...], similarity_score: float}

    5. GET /api/temporal/injections/{document_id}:
       - Returns AI injection analysis
       - Response: {injection_events: [...], injection_score: float, mixed_authorship_indicators: [...]}

    Update backend/app/models/schemas.py:
    - Add DocumentVersionCreate schema
    - Add DocumentVersionResponse schema
    - Add TimelineData schema (version, timestamp, avg_ai_prob, max_ai_prob, high_confidence_count, word_count)
    - Add TimelineResponse schema (timeline, overall_trend, ai_velocity)
    - Add InjectionEvent schema (version, timestamp, position, text, ai_probability, type)
    - Add InjectionResponse schema (injection_events, injection_score, mixed_authorship_indicators)
    - Add VersionComparison schema (added, removed, modified, similarity_score)
    - Add MixedAuthorshipIndicator schema (type, description, value)

    Create frontend/src/components/TemporalAnalysis/TemporalAnalysis.tsx:

    1. TimelineChart component:
       - Visualizes AI probability over time
       - X-axis: versions (chronological)
       - Y-axis: AI probability (0-1)
       - Line chart with trend indicator
       - Color coding: green (<0.4), yellow (0.4-0.7), red (>0.7)

    2. InjectionList component:
       - Lists detected injection events
       - Each event shows: version, timestamp, text snippet, AI probability
       - Color-coded by severity
       - Click to view context in document

    3. DraftComparison component:
       - Side-by-side comparison of two versions
       - Highlights: added (green), removed (red), modified (yellow)
       - Shows AI probability for each change

    4. MixedAuthorshipIndicators component:
       - Lists detected mixed authorship signals
       - Each indicator: type, description, severity
       - Visual badges for quick scanning

    5. Integration:
       - Fetches data from /api/temporal/timeline/{doc_id}
       - Polls for updates during analysis
       - Error handling for documents with no version history
       - Export button for timeline data

    Use CSS grid/flexbox for layout - no external charting libraries needed for simple line chart (SVG polyline).

    UI styling should match existing HeatMap component (sidebar + main content area).
  </action>
  <verify>
    curl -X GET http://localhost:8000/api/temporal/timeline/test-doc -H "Authorization: Bearer <token>" | jq '.timeline'
  </verify>
  <done>
    API endpoints return temporal data, frontend UI visualizes timeline, injections, and comparisons, matches existing UI patterns
  </done>
</task>

</tasks>

<verification>
1. DocumentVersion table stores versions with segment AI scores
2. VersionTracker stores, retrieves, and compares versions
3. TimelineAnalyzer generates timeline with trend detection
4. InjectionDetector identifies AI injection points
5. API endpoints provide temporal data
6. Frontend UI visualizes timeline, injections, and draft comparison
7. Mixed authorship indicators detected and displayed
</verification>

<success_criteria>
1. User can view writing timeline showing AI probability evolution
2. System detects AI injection points (high-AI additions in later versions)
3. User can compare two drafts to identify AI-generated content
4. Mixed authorship indicators highlight suspicious transitions
5. Document version history persists across sessions
6. Timeline visualizes trend (increasing/decreasing/stable AI probability)
7. UI integrates seamlessly with existing analysis interface
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-model-ensemble/04-03-SUMMARY.md`
</output>
