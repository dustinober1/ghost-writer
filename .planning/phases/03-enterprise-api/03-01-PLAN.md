---
phase: 03-enterprise-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/database.py
  - backend/app/models/schemas.py
  - backend/alembic/versions/003_add_api_keys.py
  - backend/app/api/routes/api_keys.py
  - backend/app/utils/auth.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Developer can create API key via POST /api/keys and receive the full key (shown only once)"
    - "Developer can authenticate requests using X-API-Key header"
    - "Developer can list their API keys with prefixes only (full keys never returned after creation)"
    - "Developer can delete API keys to revoke access"
    - "API keys have optional expiration dates and can be deactivated"
  artifacts:
    - path: "backend/app/models/database.py"
      provides: "ApiKey model with key_hash, key_prefix, user relationship"
      contains: "class ApiKey"
    - path: "backend/alembic/versions/003_add_api_keys.py"
      provides: "Database migration for api_keys table"
      contains: "def upgrade"
    - path: "backend/app/utils/auth.py"
      provides: "get_api_key_user dependency for X-API-Key authentication"
      exports: ["get_api_key_user"]
    - path: "backend/app/api/routes/api_keys.py"
      provides: "API key CRUD endpoints (create, list, delete)"
      exports: ["POST /api/keys", "GET /api/keys", "DELETE /api/keys/{id}"]
  key_links:
    - from: "backend/app/utils/auth.py"
      to: "backend/app/models/database.py"
      via: "ApiKey model query by key_hash"
      pattern: "db\\.query\\(ApiKey\\)\\.filter\\(ApiKey\\.key_hash"
    - from: "backend/app/main.py"
      to: "backend/app/api/routes/api_keys.py"
      via: "router inclusion"
      pattern: "app\\.include_router\\(api_keys_router\\)"
---

<objective>
API Key Authentication Model - Developers can authenticate API requests using secure, scoped API keys with management endpoints.

Purpose: Enable programmatic access to Ghost-Writer detection capabilities for third-party applications while maintaining security through key-based authentication. API keys provide a standard pattern for API access separate from JWT session tokens used by the web UI.

Output: Database model, authentication dependency, CRUD endpoints for API key lifecycle management
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-enterprise-api/03-RESEARCH.md

@backend/app/models/database.py
@backend/app/models/schemas.py
@backend/app/utils/auth.py
@backend/app/api/routes/auth.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ApiKey database model and tier field to User</name>
  <files>backend/app/models/database.py</files>
  <action>
    Add two changes to database.py:

    1. Add `tier` column to User model (before relationships):
    ```python
    tier = Column(String, default="free", nullable=False)  # 'free', 'pro', 'enterprise'
    ```

    2. Add ApiKey model after RefreshToken model:
    ```python
    class ApiKey(Base):
        __tablename__ = "api_keys"

        id = Column(Integer, primary_key=True, index=True)
        user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
        key_hash = Column(String, unique=True, index=True, nullable=False)  # SHA-256 hash
        key_prefix = Column(String, index=True, nullable=False)  # First 8 chars for identification
        name = Column(String, nullable=False)  # User-defined key name
        is_active = Column(Boolean, default=True, nullable=False)
        last_used = Column(DateTime, nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow)
        expires_at = Column(DateTime, nullable=True)

        user = relationship("User", back_populates="api_keys")
    ```

    3. Add api_keys relationship to User model (after refresh_tokens):
    ```python
    api_keys = relationship(
        "ApiKey", back_populates="user", cascade="all, delete-orphan"
    )
    ```

    Reference existing RefreshToken model pattern for structure.
  </action>
  <verify>grep -n "class ApiKey" backend/app/models/database.py returns the model definition</verify>
  <done>ApiKey model exists with key_hash, key_prefix, user relationship; User has tier field</done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for api_keys table and tier column</name>
  <files>backend/alembic/versions/003_add_api_keys.py</files>
  <action>
    Create new Alembic migration file:
    ```python
    """add api keys and user tier

    Revision ID: 003
    Revises: 002
    Create Date: 2025-01-19

    """
    from alembic import op
    import sqlalchemy as sa


    # revision identifiers, used by Alembic.
    revision = '003'
    down_revision = '002_add_batch_analysis_tables'
    branch_labels = None
    depends_on = None


    def upgrade():
        # Add tier column to users table
        op.add_column('users', sa.Column('tier', sa.String(), nullable=False, server_default='free'))

        # Create api_keys table
        op.create_table(
            'api_keys',
            sa.Column('id', sa.Integer(), nullable=False),
            sa.Column('user_id', sa.Integer(), nullable=False),
            sa.Column('key_hash', sa.String(), nullable=False),
            sa.Column('key_prefix', sa.String(), nullable=False),
            sa.Column('name', sa.String(), nullable=False),
            sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
            sa.Column('last_used', sa.DateTime(), nullable=True),
            sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('now()')),
            sa.Column('expires_at', sa.DateTime(), nullable=True),
            sa.ForeignKeyConstraint(['user_id'], ['users.id']),
            sa.PrimaryKeyConstraint('id')
        )
        op.create_index(op.f('ix_api_keys_key_hash'), 'api_keys', ['key_hash'], unique=True)
        op.create_index(op.f('ix_api_keys_key_prefix'), 'api_keys', ['key_prefix'], unique=False)


    def downgrade():
        op.drop_index(op.f('ix_api_keys_key_prefix'), table_name='api_keys')
        op.drop_index(op.f('ix_api_keys_key_hash'), table_name='api_keys')
        op.drop_table('api_keys')
        op.drop_column('users', 'tier')
    ```

    Set down_revision to match the actual latest migration ID from 002_add_batch_analysis_tables.py.
  </action>
  <verify>ls -la backend/alembic/versions/003*.py shows the migration file exists</verify>
  <done>Migration file created with upgrade() and downgrade() methods</done>
</task>

<task type="auto">
  <name>Task 3: Add API key authentication dependency to auth.py</name>
  <files>backend/app/utils/auth.py</files>
  <action>
    Add to backend/app/utils/auth.py (after existing get_current_user_optional function):

    ```python
    from fastapi.security import APIKeyHeader
    from fastapi import Security
    from app.models.database import ApiKey
    import hashlib

    api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)


    def get_api_key_user(
        request: Request,
        db: Session = Depends(get_db),
        api_key: str = Security(api_key_header)
    ) -> Optional[User]:
        """
        Validate API key and return user.
        Returns None if no API key provided or invalid.
        Supports dual auth: JWT Bearer token or X-API-Key header.
        """
        if not api_key:
            return None

        # Hash the provided key and compare with stored hash
        key_hash = hashlib.sha256(api_key.encode()).hexdigest()

        api_key_record = db.query(ApiKey).filter(
            ApiKey.key_hash == key_hash,
            ApiKey.is_active == True
        ).first()

        if not api_key_record:
            return None

        # Check expiration
        if api_key_record.expires_at and api_key_record.expires_at < datetime.utcnow():
            return None

        # Update last_used timestamp
        api_key_record.last_used = datetime.utcnow()
        db.commit()

        # Get associated user
        user = db.query(User).filter(User.id == api_key_record.user_id).first()

        # Check if user is active
        if not user or not user.is_active:
            return None

        return user


    def get_current_user_or_api_key(
        request: Request,
        db: Session = Depends(get_db)
    ) -> Optional[User]:
        """
        Get current user from JWT token OR API key.
        Returns None if neither is valid.
        """
        # First try JWT token
        token = extract_token_from_header(request)
        if token:
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                email: str = payload.get("sub")
                if email:
                    user = db.query(User).filter(User.email == email).first()
                    if user and user.is_active:
                        return user
            except (JWTError, Exception):
                pass

        # Then try API key
        api_key = request.headers.get("X-API-Key")
        if api_key:
            key_hash = hashlib.sha256(api_key.encode()).hexdigest()
            api_key_record = db.query(ApiKey).filter(
                ApiKey.key_hash == key_hash,
                ApiKey.is_active == True
            ).first()

            if api_key_record:
                if not api_key_record.expires_at or api_key_record.expires_at >= datetime.utcnow():
                    api_key_record.last_used = datetime.utcnow()
                    db.commit()

                    user = db.query(User).filter(User.id == api_key_record.user_id).first()
                    if user and user.is_active:
                        return user

        return None
    ```

    Note: Import datetime at the top if not already imported.
  </action>
  <verify>grep -n "def get_api_key_user" backend/app/utils/auth.py returns function definition</verify>
  <done>get_api_key_user and get_current_user_or_api_key functions added to auth.py</done>
</task>

<task type="auto">
  <name>Task 4: Create API key management endpoints</name>
  <files>backend/app/api/routes/api_keys.py</files>
  <action>
    Create new file backend/app/api/routes/api_keys.py:

    ```python
    from fastapi import APIRouter, Depends, HTTPException, status, Body
    from sqlalchemy.orm import Session
from datetime import datetime, timedelta
    from typing import List
    import secrets
    import hashlib

    from app.models.database import get_db, User, ApiKey
    from app.utils.auth import get_current_user
    from app.models.schemas import BaseModel

    router = APIRouter(prefix="/api/keys", tags=["api-keys"])


    # Pydantic schemas for API keys
    class ApiKeyCreate(BaseModel):
        name: str
        expires_in_days: int = None


    class ApiKeyResponse(BaseModel):
        id: int
        key_prefix: str
        name: str
        is_active: bool
        created_at: datetime
        expires_at: datetime = None
        last_used: datetime = None


    class ApiKeyCreatedResponse(BaseModel):
        key: str  # Only shown on creation
        key_prefix: str
        name: str
        expires_at: datetime = None


    @router.post("", response_model=ApiKeyCreatedResponse)
    async def create_api_key(
        name: str = Body(..., embed=True, min_length=1, max_length=100),
        expires_in_days: int = Body(None, gt=0, le=365),
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        """Generate a new API key for the current user. Returns the full key (only shown once)."""
        # Check user's API key limit (free: 3 keys, pro: 10, enterprise: unlimited)
        existing_keys = db.query(ApiKey).filter(
            ApiKey.user_id == current_user.id,
            ApiKey.is_active == True
        ).count()

        tier = current_user.tier if hasattr(current_user, 'tier') else "free"
        max_keys = {"free": 3, "pro": 10, "enterprise": 9999}.get(tier, 3)

        if existing_keys >= max_keys:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Maximum API key limit reached ({max_keys} keys for {tier} tier)"
            )

        # Generate secure random key (32 bytes = 43 chars in urlsafe encoding)
        raw_key = f"gw_{secrets.token_urlsafe(32)}"

        # Hash for storage (SHA-256)
        key_hash = hashlib.sha256(raw_key.encode()).hexdigest()

        # Store prefix for identification (first 8 chars after prefix)
        key_prefix = raw_key[:8]

        # Calculate expiration
        expires_at = None
        if expires_in_days:
            expires_at = datetime.utcnow() + timedelta(days=expires_in_days)

        # Save to database
        api_key = ApiKey(
            user_id=current_user.id,
            key_hash=key_hash,
            key_prefix=key_prefix,
            name=name,
            expires_at=expires_at
        )
        db.add(api_key)
        db.commit()
        db.refresh(api_key)

        # Return full key only on creation
        return ApiKeyCreatedResponse(
            key=raw_key,
            key_prefix=key_prefix,
            name=name,
            expires_at=expires_at
        )


    @router.get("", response_model=List[ApiKeyResponse])
    async def list_api_keys(
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        """List all API keys for the current user (prefixes only, never full keys)."""
        api_keys = db.query(ApiKey).filter(
            ApiKey.user_id == current_user.id
        ).order_by(ApiKey.created_at.desc()).all()

        return [
            ApiKeyResponse(
                id=key.id,
                key_prefix=key.key_prefix,
                name=key.name,
                is_active=key.is_active,
                created_at=key.created_at,
                expires_at=key.expires_at,
                last_used=key.last_used
            )
            for key in api_keys
        ]


    @router.delete("/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
    async def delete_api_key(
        key_id: int,
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        """Delete (revoke) an API key."""
        api_key = db.query(ApiKey).filter(
            ApiKey.id == key_id,
            ApiKey.user_id == current_user.id
        ).first()

        if not api_key:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="API key not found"
            )

        db.delete(api_key)
        db.commit()

        return None
    ```

    Follow existing auth.py patterns for error handling and response formatting.
  </action>
  <verify>grep -n "router = APIRouter" backend/app/api/routes/api_keys.py returns router definition</verify>
  <done>api_keys.py created with POST /api/keys, GET /api/keys, DELETE /api/keys/{id}</done>
</task>

<task type="auto">
  <name>Task 5: Wire API keys router into main.py</name>
  <files>backend/app/main.py</files>
  <action>
    1. Import the api_keys router at the top (after batch import):
    ```python
    from app.api.routes import auth, analysis, fingerprint, rewrite, analytics, account, admin, batch, api_keys
    ```

    2. Include the router (after batch router):
    ```python
    app.include_router(api_keys.router)
    ```

    Place the include_router statement after app.include_router(batch.router).
  </action>
  <verify>grep "api_keys" backend/app/main.py returns import and include_router lines</verify>
  <done>api_keys router imported and included in FastAPI app</done>
</task>

</tasks>

<verification>
1. Run migration: `alembic upgrade head` - api_keys table and tier column created
2. Start backend: `docker-compose up backend` - no import errors
3. Test API key creation (requires JWT auth):
   ```bash
   # First login to get token
   TOKEN=$(curl -X POST http://localhost:8000/api/auth/login-json \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"testpass123"}' | jq -r '.access_token')

   # Create API key
   curl -X POST http://localhost:8000/api/keys \
     -H "Authorization: Bearer $TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"name":"Test Key","expires_in_days":30}'
   ```
   Should return: `{"key":"gw_...","key_prefix":"gw_xxxxxx","name":"Test Key","expires_at":"..."}`

4. Test API key authentication:
   ```bash
   # Use API key to access protected endpoint
   curl http://localhost:8000/api/analytics/overview \
     -H "X-API-Key: gw_<full_key_from_creation>"
   ```
   Should return analytics data (not 401)

5. Test list keys:
   ```bash
   curl http://localhost:8000/api/keys \
     -H "Authorization: Bearer $TOKEN"
   ```
   Should return array of keys with prefixes only (no full keys)
</verification>

<success_criteria>
1. ApiKey model exists in database.py with key_hash, key_prefix, user relationship
2. User model has tier column with default "free"
3. Alembic migration 003_add_api_keys.py exists and runs successfully
4. POST /api/keys creates API key and returns full key (shown only once)
5. GET /api/keys lists user's keys with prefixes only
6. DELETE /api/keys/{id} revokes the key
7. X-API-Key header authentication works via get_api_key_user dependency
8. API keys have optional expiration and can be deactivated
</success_criteria>

<output>
After completion, create `.planning/phases/03-enterprise-api/03-01-SUMMARY.md`
</output>
