---
phase: 05-enhanced-fingerprinting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/database.py
  - backend/app/models/schemas.py
  - backend/app/ml/fingerprint/corpus_builder.py
  - backend/app/api/routes/fingerprint.py
  - backend/app/services/fingerprint_service.py
  - frontend/src/services/api.ts
  - frontend/src/components/ProfileManager/CorpusBuilder.tsx
autonomous: true

must_haves:
  truths:
    - "User can upload multiple writing samples (10+) to build a corpus"
    - "System stores samples with metadata (source type, timestamp, word count, extracted features)"
    - "User can view corpus summary showing sample count and distribution by source type"
    - "System validates minimum 10 samples before allowing enhanced fingerprint generation"
    - "User can delete individual samples from corpus"
  artifacts:
    - path: "backend/app/models/database.py"
      provides: "FingerprintSample table with features JSON, source_type, written_at fields"
      contains: "class FingerprintSample"
    - path: "backend/app/models/database.py"
      provides: "EnhancedFingerprint table with corpus_size, method, alpha, feature_statistics"
      contains: "class EnhancedFingerprint"
    - path: "backend/app/ml/fingerprint/corpus_builder.py"
      provides: "FingerprintCorpusBuilder class for multi-sample aggregation"
      exports: ["FingerprintCorpusBuilder", "add_sample", "build_fingerprint"]
    - path: "backend/app/api/routes/fingerprint.py"
      provides: "Corpus management endpoints (POST /corpus/add, GET /corpus/status, DELETE /corpus/sample/{id})"
      exports: ["add_corpus_sample", "get_corpus_status", "delete_corpus_sample"]
    - path: "frontend/src/components/ProfileManager/CorpusBuilder.tsx"
      provides: "UI for managing writing samples with bulk upload and sample list"
      min_lines: 200
  key_links:
    - from: "backend/app/ml/fingerprint/corpus_builder.py"
      to: "backend/app/ml/feature_extraction.py"
      via: "extract_feature_vector import"
      pattern: "from app.ml.feature_extraction import extract_feature_vector"
    - from: "backend/app/api/routes/fingerprint.py"
      to: "FingerprintSample database table"
      via: "SQLAlchemy ORM query"
      pattern: "FingerprintSample.*user_id"
    - from: "frontend/src/components/ProfileManager/CorpusBuilder.tsx"
      to: "/api/fingerprint/corpus/*"
      via: "fingerprintAPI corpus methods in api.ts"
      pattern: "fingerprintAPI.corpus"
---

<objective>
Build corpus-based fingerprint infrastructure enabling users to aggregate 10+ writing samples with metadata tracking.

Purpose: Single-sample fingerprints (current implementation) lack statistical robustness and produce high false-positive drift alerts. A multi-sample corpus provides feature variance tracking, supports time-weighted training, and enables confidence interval calculations.

Output: Database tables for samples and enhanced fingerprints, corpus builder ML module, API endpoints, and React UI component for sample management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enhanced-fingerprinting/05-enhanced-fingerprinting-RESEARCH.md

@backend/app/ml/fingerprint.py
@backend/app/ml/feature_extraction.py
@backend/app/models/database.py
@backend/app/models/schemas.py
@backend/app/api/routes/fingerprint.py
@backend/app/services/fingerprint_service.py
@frontend/src/components/ProfileManager/ProfileManager.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database models for corpus-based fingerprinting</name>
  <files>backend/app/models/database.py</files>
  <action>
    Add two new SQLAlchemy models to database.py:

    1. **FingerprintSample** - Stores individual writing samples with extracted features:
       - id (Integer, primary_key, index=True)
       - user_id (Integer, ForeignKey("users.id"), nullable=False, index=True)
       - text_content (Text, nullable=False) - Original text for reference
       - source_type (String, nullable=False) - 'email', 'essay', 'blog', 'academic', 'document', 'manual'
       - features (JSON, nullable=False) - 27-element stylometric feature array
       - word_count (Integer, nullable=False)
       - created_at (DateTime, default=datetime.utcnow, index=True)
       - written_at (DateTime, nullable=True) - When text was originally written (for time-weighting)
       - relationship: user = relationship("User", back_populates="fingerprint_samples")

    2. **EnhancedFingerprint** - Stores corpus-based fingerprint with metadata:
       - id (Integer, primary_key=True, index=True)
       - user_id (Integer, ForeignKey("users.id"), nullable=False, unique=True)
       - feature_vector (JSON, nullable=False) - 27-element averaged feature vector
       - feature_statistics (JSON, nullable=True) - Per-feature mean/std/variance for confidence intervals
       - corpus_size (Integer, default=0, nullable=False) - Number of samples used
       - method (String, default="time_weighted", nullable=False) - 'time_weighted', 'average', 'source_weighted'
       - alpha (Float, default=0.3, nullable=False) - EMA smoothing parameter
       - created_at (DateTime, default=datetime.utcnow)
       - updated_at (DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
       - source_distribution (JSON, nullable=True) - Count of samples by source_type
       - relationship: user = relationship("User", back_populates="enhanced_fingerprints")

    3. Add relationship to User model:
       - enhanced_fingerprints = relationship("EnhancedFingerprint", back_populates="user", cascade="all, delete-orphan")
       - fingerprint_samples = relationship("FingerprintSample", back_populates="user", cascade="all, delete-orphan")

    Use snake_case throughout. Import datetime from datetime module.
  </action>
  <verify>
    Run: python -c "from app.models.database import FingerprintSample, EnhancedFingerprint; print('Models imported successfully')"
    Verify: FingerprintSample has features JSON column, EnhancedFingerprint has feature_statistics JSON column
  </verify>
  <done>
    Database models compile without errors, all required columns and relationships defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Pydantic schemas for corpus operations</name>
  <files>backend/app/models/schemas.py</files>
  <action>
    Add the following Pydantic schemas to schemas.py (after existing FingerprintStatus, before Analysis Schemas section):

    1. **FingerprintSampleCreate** - Request schema for adding samples:
       ```python
       class FingerprintSampleCreate(BaseModel):
           text_content: str = Field(..., min_length=10)
           source_type: str = Field(default="manual", pattern="^(email|essay|blog|academic|document|manual)$")
           written_at: Optional[datetime] = None
       ```

    2. **FingerprintSampleResponse** - Response schema for samples:
       ```python
       class FingerprintSampleResponse(BaseModel):
           id: int
           user_id: int
           source_type: str
           word_count: int
           created_at: datetime
           written_at: Optional[datetime] = None
           text_preview: str  # First 100 chars of text_content

           class Config:
               from_attributes = True
       ```

    3. **CorpusStatus** - Corpus summary response:
       ```python
       class CorpusStatus(BaseModel):
           sample_count: int
           total_words: int
           source_distribution: Dict[str, int]
           ready_for_fingerprint: bool
           samples_needed: int  # How many more samples needed (min 10)
           oldest_sample: Optional[datetime] = None
           newest_sample: Optional[datetime] = None
       ```

    4. **EnhancedFingerprintResponse** - Response for enhanced fingerprint:
       ```python
       class EnhancedFingerprintResponse(BaseModel):
           id: int
           user_id: int
           corpus_size: int
           method: str
           alpha: float
           source_distribution: Optional[Dict[str, int]] = None
           created_at: datetime
           updated_at: datetime

           class Config:
               from_attributes = True
       ```

    Add proper imports: Optional from typing, Dict, Field from pydantic.
  </action>
  <verify>
    Run: python -c "from app.models.schemas import FingerprintSampleCreate, CorpusStatus, EnhancedFingerprintResponse; print('Schemas imported successfully')"
  </verify>
  <done>
    All schemas validate correctly with pydantic, field constraints defined
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement FingerprintCorpusBuilder module</name>
  <files>backend/app/ml/fingerprint/corpus_builder.py</files>
  <action>
    Create new file backend/app/ml/fingerprint/__init__.py with: from .corpus_builder import FingerprintCorpusBuilder

    Create backend/app/ml/fingerprint/corpus_builder.py with:

    1. **FingerprintCorpusBuilder** class with methods:
       - __init__(self, min_samples: int = 10) - Initialize with minimum samples constant
       - add_sample(self, text: str, source_type: str = "manual", timestamp: Optional[datetime] = None) -> Dict
         * Validates text is not empty
         * Extracts features using extract_feature_vector(text)
         * Stores sample with metadata (features, timestamp, source_type, word_count, raw_features)
         * Returns sample metadata dictionary
       - build_fingerprint(self, method: str = "time_weighted", alpha: float = 0.3) -> Dict
         * Validates len(self.samples) >= MIN_SAMPLES_FOR_FINGERPRINT (10)
         * Sorts samples by timestamp
         * Calls _build_time_weighted(), _build_average(), or _build_source_weighted()
         * Returns fingerprint dict with feature_vector, sample_count, method, feature_statistics
       - get_corpus_summary(self) -> Dict with sample_count, total_words, source_distribution, ready_for_fingerprint

    2. **Time-weighted building** (_build_time_weighted method):
       - Iterate sorted_samples by timestamp
       - Apply EMA: new_vector = (1 - alpha) * old + alpha * new
       - Track feature statistics using Welford's online algorithm (mean, variance per feature)
       - Include corpus metadata: date_range (earliest/latest), source_distribution, average_word_count

    3. **Source-weighted building** (_build_source_weighted method):
       - Define source_weights: essay=1.2, academic=1.3, blog=1.0, email=0.9, document=1.1, manual=1.0
       - Compute weighted average using source weights

    4. **Constants**:
       - MIN_SAMPLES_FOR_FINGERPRINT = 10 (class attribute)
       - Import extract_feature_vector, FEATURE_NAMES from app.ml.feature_extraction

    Use numpy for vector operations. Handle edge cases: empty samples list, insufficient samples.
  </action>
  <verify>
    Run: python -c "from app.ml.fingerprint.corpus_builder import FingerprintCorpusBuilder; print('CorpusBuilder imported'); print(f'MIN_SAMPLES: {FingerprintCorpusBuilder.MIN_SAMPLES_FOR_FINGERPRINT}')"
  </verify>
  <done>
    Module imports successfully, MIN_SAMPLES constant accessible, class has required methods
  </done>
</task>

<task type="auto">
  <name>Task 4: Add corpus management API endpoints</name>
  <files>backend/app/api/routes/fingerprint.py</files>
  <action>
    Extend existing backend/app/api/routes/fingerprint.py with new endpoints:

    1. **POST /api/fingerprint/corpus/add** - Add sample to corpus:
       - Accepts: FingerprintSampleCreate (text_content, source_type, written_at)
       - Validates text length (min 10 chars)
       - Extracts features using extract_feature_vector
       - Creates FingerprintSample record with features JSON, word_count
       - Returns: FingerprintSampleResponse
       - Apply @general_rate_limit decorator

    2. **GET /api/fingerprint/corpus/status** - Get corpus summary:
       - Queries user's FingerprintSample records
       - Computes: sample_count, total_words, source_distribution, ready_for_fingerprint
       - Returns: CorpusStatus with samples_needed = max(0, 10 - sample_count)
       - Include oldest_sample and newest_sample timestamps

    3. **GET /api/fingerprint/corpus/samples** - List all samples (paginated):
       - Query params: page=1, page_size=20
       - Returns List[FingerprintSampleResponse]
       - Order by created_at DESC

    4. **DELETE /api/fingerprint/corpus/sample/{sample_id}** - Delete sample:
       - Validates sample belongs to current_user
       - Deletes sample, returns 204 No Content

    5. **POST /api/fingerprint/corpus/generate** - Generate enhanced fingerprint:
       - Validates corpus_size >= 10
       - Uses FingerprintCorpusBuilder to build fingerprint
       - Creates/updates EnhancedFingerprint record
       - Returns: EnhancedFingerprintResponse

    Import new schemas: FingerprintSampleCreate, FingerprintSampleResponse, CorpusStatus, EnhancedFingerprintResponse
    Import database models: FingerprintSample, EnhancedFingerprint
    Import FingerprintCorpusBuilder: from app.ml.fingerprint.corpus_builder import FingerprintCorpusBuilder
  </action>
  <verify>
    Run: python -c "from app.api.routes.fingerprint import router; print(f'Fingerprint routes: {[p.path for p in router.routes]}')"
    Verify new routes exist: /corpus/add, /corpus/status, /corpus/samples, /corpus/sample/{sample_id}, /corpus/generate
  </verify>
  <done>
    All endpoints registered, route paths correct, request/response schemas defined
  </done>
</task>

<task type="auto">
  <name>Task 5: Update FingerprintService for corpus operations</name>
  <files>backend/app/services/fingerprint_service.py</files>
  <action>
    Extend FingerprintService class in backend/app/services/fingerprint_service.py with new methods:

    1. **add_corpus_sample(self, db, user_id, text_content, source_type="manual", written_at=None)**:
       - Extract features using extract_feature_vector
       - Create FingerprintSample record with features JSON
       - Return FingerprintSample object

    2. **get_corpus_status(self, db, user_id)**:
       - Query all FingerprintSample for user
       - Calculate sample_count, total_words, source_distribution
       - Compute ready_for_fingerprint = sample_count >= 10
       - Return dict matching CorpusStatus schema

    3. **list_corpus_samples(self, db, user_id, page=1, page_size=20)**:
       - Query FingerprintSample with pagination
       - Order by created_at DESC
       - Return list of FingerprintSampleResponse

    4. **delete_corpus_sample(self, db, user_id, sample_id)**:
       - Validate sample belongs to user
       - Delete sample
       - Return True if deleted

    5. **generate_enhanced_fingerprint(self, db, user_id, method="time_weighted", alpha=0.3)**:
       - Get all FingerprintSample for user
       - Use FingerprintCorpusBuilder to build fingerprint
       - Create/update EnhancedFingerprint record
       - Return EnhancedFingerprint object

    Add imports: from app.models.database import FingerprintSample, EnhancedFingerprint
    Import: from app.ml.fingerprint.corpus_builder import FingerprintCorpusBuilder
  </action>
  <verify>
    Run: python -c "from app.services.fingerprint_service import get_fingerprint_service; fs = get_fingerprint_service(); print([m for m in dir(fs) if not m.startswith('_')])"
    Verify new methods exist: add_corpus_sample, get_corpus_status, generate_enhanced_fingerprint
  </verify>
  <done>
    Service methods defined, integrate with FingerprintCorpusBuilder correctly
  </done>
</task>

<task type="auto">
  <name>Task 6: Add corpus API methods to frontend</name>
  <files>frontend/src/services/api.ts</files>
  <action>
    Extend fingerprintAPI object in frontend/src/services/api.ts with new methods:

    1. **corpus.add(text: string, sourceType: string, writtenAt?: string)**:
       - POST to /api/fingerprint/corpus/add
       - Body: { text_content: text, source_type: sourceType, written_at: writtenAt }
       - Returns: FingerprintSampleResponse

    2. **corpus.getStatus()**:
       - GET from /api/fingerprint/corpus/status
       - Returns: CorpusStatus

    3. **corpus.getSamples(page?: number, pageSize?: number)**:
       - GET from /api/fingerprint/corpus/samples with query params
       - Returns: FingerprintSampleResponse[]

    4. **corpus.deleteSample(sampleId: number)**:
       - DELETE to /api/fingerprint/corpus/sample/{sampleId}
       - Returns: void

    5. **corpus.generateFingerprint(method?: string, alpha?: number)**:
       - POST to /api/fingerprint/corpus/generate
       - Body: { method, alpha }
       - Returns: EnhancedFingerprintResponse

    Extend FingerprintSampleResponse, CorpusStatus, EnhancedFingerprintResponse interfaces in api.ts if needed.
    Use consistent error handling with getErrorMessage helper.
  </action>
  <verify>
    Run: grep "corpus:" frontend/src/services/api.ts
    Verify: corpus.add, corpus.getStatus, corpus.getSamples, corpus.deleteSample, corpus.generateFingerprint defined
  </verify>
  <done>
    All corpus API methods defined with proper TypeScript types and error handling
  </done>
</task>

<task type="auto">
  <name>Task 7: Create CorpusBuilder React component</name>
  <files>frontend/src/components/ProfileManager/CorpusBuilder.tsx</files>
  <action>
    Create new component frontend/src/components/ProfileManager/CorpusBuilder.tsx:

    1. **State management**:
       - corpusStatus: CorpusStatus | null
       - samples: FingerprintSampleResponse[]
       - loading: boolean
       - selectedSourceType: string (dropdown: essay, academic, blog, email, document, manual)
       - uploadText: string (textarea for pasting text)

    2. **Key features**:
       - Progress indicator showing samples / 10 (with color coding: red <5, yellow 5-9, green 10+)
       - Source type distribution chart (simple bar showing count per source)
       - Sample list table with columns: Source Type, Date, Word Count, Preview, Delete button
       - File upload support (reuse existing file upload pattern from ProfileManager)
       - "Generate Enhanced Fingerprint" button (enabled when sample_count >= 10)

    3. **Actions**:
       - addSample(text, sourceType, writtenAt?) - calls corpus.add(), refreshes status
       - deleteSample(sampleId) - confirmation dialog, then corpus.deleteSample()
       - generateFingerprint() - calls corpus.generateFingerprint(), shows success toast

    4. **UI layout**:
       - Top: Status cards (Sample Count, Ready Status, Source Distribution)
       - Middle: Upload section with tabs (File Upload / Paste Text / Source Type selector)
       - Bottom: Sample list table with pagination
       - Floating "Generate Fingerprint" button when ready

    Use existing components: Card, Button, Badge, Alert, Textarea, Tabs
    Use icons from lucide-react: Upload, FileText, Trash2, CheckCircle, Sparkles
    Apply consistent styling with ProfileManager.tsx
  </action>
  <verify>
    Run: grep -E "(CorpusStatus|FingerprintSampleResponse|corpus\.)" frontend/src/components/ProfileManager/CorpusBuilder.tsx | wc -l
    Should find >10 matches (component uses corpus API)
  </verify>
  <done>
    Component renders without errors, displays corpus status, allows adding/deleting samples
  </done>
</task>

<task type="auto">
  <name>Task 8: Integrate CorpusBuilder into ProfileManager</name>
  <files>frontend/src/components/ProfileManager/ProfileManager.tsx</files>
  <action>
    Update frontend/src/components/ProfileManager/ProfileManager.tsx to integrate CorpusBuilder:

    1. Add import: import CorpusBuilder from './CorpusBuilder';

    2. Add new tab to existing Tabs component:
       - Insert after "Paste Text" tab: <TabsTrigger value="corpus">Enhanced Corpus</TabsTrigger>

    3. Add new TabsContent:
       ```tsx
       <TabsContent value="corpus">
         <CorpusBuilder />
       </TabsContent>
       ```

    4. Update recommendation card to mention enhanced fingerprint when applicable:
       - If sample_count >= 10: "You have enough samples for an enhanced fingerprint with time-weighted training"

    Keep existing functionality intact (single-sample upload, basic fingerprint generation).
  </action>
  <verify>
    Run: grep -E "(CorpusBuilder|corpus)" frontend/src/components/ProfileManager/ProfileManager.tsx
    Verify: CorpusBuilder imported and used in tabs
  </verify>
  <done>
    ProfileManager shows new "Enhanced Corpus" tab, CorpusBuilder renders correctly
  </done>
</task>

</tasks>

<verification>
1. Backend starts without errors: python -m app.main
2. Database tables created: FingerprintSample, EnhancedFingerprint
3. API endpoints accessible: GET /api/fingerprint/corpus/status returns 200
4. Frontend renders corpus builder: Navigate to Profile tab, click "Enhanced Corpus" tab
5. Can add samples: Paste text, select source type, submit -> sample count increments
6. Progress indicator works: Shows 0/10, 5/10, 10/10 correctly
7. Generate button enables: When 10 samples reached, button becomes clickable
8. Sample list displays: Shows source type, date, word count for each sample
9. Delete sample works: Click delete -> sample removed from list
</verification>

<success_criteria>
- User can upload 10+ writing samples with source type metadata
- Corpus status shows sample count and distribution by source type
- System validates minimum 10 samples before enabling enhanced fingerprint generation
- User can view and delete individual samples from corpus
- Database stores extracted features for each sample enabling time-weighted training
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-fingerprinting/05-01-SUMMARY.md` with:
- Files modified
- Database schema changes (new tables)
- API endpoints added
- Any deviations from plan
- Performance notes (corpus query performance)
</output>
